integer symbol     errno ???
to get at errno  you include the header  errno.h
4

of all the system calls covered in the book, about 60% return -1 on an error, about 20% return sth. else ,such as  NULL, zero , or a special  symbol like   SIG_ERR (??)  ,and about 20% don't report errors at all     (so we have to read the documentation for each one)iao

errno 应该是一个全局变量吧 ？？ 所有的 system call 都有权限修改??(什么的全局变量）
errno 用来包含出错的信息，set by system call

暂时略过 error handling 这一节

关于 UNIX standards   （API ，specifications(规格），） ，如果一般说 conforms to  POIX,(一般指 POIX 1990），而且一些新 features ，like 
real time,  threads are opional  (you have to investigate the status of optional features separately)

接着讲了一些关于 用于 preprocessor 处理的一些定义，比较烦琐，用于 telling the system what you want (what standard),   asking the system what it has(maybe  what standards it can offer)

Common Header Files
all the examples in the book include the common header file       defs.h(里面几乎包含了所有的常用头文件）,这个头文件是作者自己写的

stduy sesources
Open Group SUS(Single Unix Specification)  at        www.unix.org/version3  
GNU C Library  a great source for coding example (available for downloading at    www.gnu.org/software/libc)

在这个系统下写C程序，#include< .h>的头文件在目录    /usr/include里， 我给这个目录新添了一个文件（用了 sudo 命令才做到 ） ，defs.h,里面包含了头文件（#include<stdio.h>)  ,  在程序中用这个头文件   defs.h,   it's working!!!

_SC_OPEN_MAX   （定义的是一个进程可以有多少个file descriptors 与它相关，linux 2.4 是  1024） 这个是在哪个头文件里定义的？？？在 defs.h里面包含了那么多都还不行）

用sudo命令把自己写的编译好的程序（hello world)复制到 /bin 目录下，  可以在bash下直接调用  ，it's working!!!

介绍了signals (p6),后面再细研究

ls | wc  是什么意思？？？？

files don't have names, they have numbers called i-numbers, An i-number is an index into an array of i-nodes,kept at the front of each region of disk that contains a UNIX file system.the information an i-node contains include:
type of file(regular,directory,socket??....)
number of links
owner's user and group ID
three sets of access permissions(owner,group, others)
size in bytes
time of last access, last modified,and status change(when the i-node itself was last modified)
pointers to disk blocks containing the file's contents

系统调用中使用的那些 Flags都是在哪定义的， open()  creat().... 中使用的那些，  哪个头文件中定义的，  kernel定义的还是 ，  C include 库定义的？？？

 ls -l 可详细列出文件信息,包括使用权限

修改了  /etc/passwd 里面对应的 xiaoyu 那一条, 是我自己这个 account的信息, 比如我的默认  shell  是/bin/bash  ,  可以改(像改为 /bin/sh) , 应该还可以改密码

write 命令可以与 其它的 user 和 terminal 进行通信    write user  pty

env 可以用来显示环境变量

ps 查看当前进程    process snapshot
 

init  is  the  parent  of all processes on the system, it is executed by the kernel and is responsible for starting all other pro‐
       cesses; it is the parent of all processes whose natural parents have died and it is responsible for reaping those when they die.

       Processes managed by init are known as jobs and are defined by files in the /etc/init directory.  See init(5) for more details  on

process management daemonb

each process has its own    file descriptor table

exec 系列函数(no function named exec),  execv, execl,  execvp,execlp,   execve, execle
execAB ,         A表示 l(arguments int the  call(list))  , (arguments in an array(vector)),
                 B(p , environment variable PATH should be used to search for the program)( e, to indicate a particular environment to be used)(是完全不同的一个环境, 要由一个环境变量数组来说明)

exec,  fork ,  exit,  wait 这4组函数 round out the primitives of process control.

interpreter files       begin with a line        // this kind of files are used for what???
#! pathname .... 

关于 execlp有一个问题没有解决(写了一个小程序,在那个小程序里)

_exit is from UNIX ,    _Exit is from standard C   they behave identical in all aspects
exit is also form standard C

每一个进程都有一个filedescriptor table, 前三个 0 1 2 都划给了这个进程的 标准输入, 标准输出, 错误处理 ,  

file operation 基本5个函数就够了  open , creat, read , write, lseek   ,     在 unistd.h 头文件里

stat structure 是谁定义的,用作什么用???

File types :    Regular file ,  Directory file,   Block special file , Character special file  ,   FIFO,  Socket ,  Symbolic link

system function 用来执行shell里面的工具

/etc  里面的应该是系统要用的一系列文件, 像 /etc/passwd   /ect/group   /ect/shadow  (放加密过的密码)  /etc/hosts  /etc/networks  /etc/protocols 
/etc/services  .....  且这些都有对应的 头文件(里面定义了相应操作的函数)    和   一个 structure(定义了这些文件中的每一个field) , 

SINGLA  signal

various macros are defined in  <sys/wait.h>

linux  下各种消息的定义都在    <bits/signum.h>  中 

signals are software interupts

与signal 有关的函数    <signal.h>
signal      signal 是定义为一个函数指针 ??   
kill()                  shell 中的 kill工具就是向 某个进程发送某个信号,   
int  raise(int signo)      是让进程给自己发送   signal
unsigned int alarm(unsigned int seconds)   the SIGALRM  signal is generated by the kernel,   the default action is to terminate the process  
int  pause(void)    suspends a process untill a signal is caught
unsigned int sleep(unsigned int seconds)    it makes the process sleeps for the time specified or until a signal is caught by the process and the signal handler returns     ,  in the first case , it returns 0 ;  in the second case , it returns the number of unslept seconds

sigprocmask()
sigpending()
sigaction()
abort()    system()   sleep()

在后台运行某个程序      后面加 &  

C没有官方标准, K&R C成为大家接受的标准,  且C标准没有定义C库, 因为缺乏任何官方标准, UNIX实现的库成为事实上的标准(C语言是和UNIX一同发明的) 

signal就是用宏定义的一个数

void (* signal(int signo, void (* func)(int))) (int)     若无误,返回的函数指针就是  func,  否则返回   SIG_ERR (一个宏)

SIGUSR1 和 SIGUSR2 是标准头文件中定义的两件 user-defined signal  , for use in application programs

job control shell 是什么 , 如果一个shell可以在命令后键入 & 让它在后台运行,应该就是说它可以支持  job control

wait() 返回的是进程的状态, 进程有哪几种状态??

getpid() 返回自身进程的  ID

如果文件名前有  .  ,则表明这是一个隐藏文件

od 命令, 输出二进制,及二进制的各种表示,  关于一个文件的

常用两个搜索软件  whereis   locate    whereis 和 locate 是用数据库来搜索数据, 所以相当快, 并且没有搜索实际硬盘,所以比较快???

用vi编辑好一个文件后,它应该会自动在最后加上一个 换行符   \n

updatedb可以更新系统的数据库, 而locate就是基于这个数据库去查找文件(所以很快), 如果创建一个新的文件,不更新,当然马上用locate  是找不到的
这个数据库文件是 /var/lib/mlocate/mlocate.db

vi 中不可以直接从编辑模式到命令模式, 必须点 EXC 先到一般模式, 再到命令模式

type可以判断一个命令是 shell  built-in 的,还是另外的

内存中的数据都写入 /proc/* 目录 ,其中每个进程都有自己单独的目录 !!!
如果想自行编写某些工具软件,这个目录下的相关文件可能会有帮助

linux的核心提供很多核心相关函数库与外部参数,这些核心相关信息大多放在 /usr/include   /lib   /usr/lib 中

initial kernel-level process(进程分kernel 的 和  user 的)

init  的  process ID  是 1

关于 thread :

a thread ID is represented by  pthread_t data type.  Implementations are allowed to use a structure to represent this data type
( linux uses an unsigned long integer for   pthread_t)   而进程程的ID  pid_t 是 non-negative integer
 
 线程相关头文件  <pthread.h> , pthread is short for   POXI thread. 

int pthread_create(pthread_t * tidp, pthread_attr_t * attr,  void *(*start_rtn)(void*),  void * arg)
所以要创建一个thread, 必须先要创建一个 pthread_t 的 pointer, 作为参数传进去, 同样,如果不使用它的 default  attributes, 同样也要自己创建一个 pthread_attr_t 的指针, 传进去, 并只能用内核指拱的 system call 修改 attribute 的 值( 这里没弄明白, 既然 attribute structure 是内核 的 data structure, 为什么又要自己来定义这样一个指什, 而且并不给它(在栈里面)分配空间 ,     函数指针 start_rtn 是 thread , 开始执行的地方

read , pread 都是 read from a file  ,   read , write 都返回的是 读写字符的个数

(pipe descirptor 也是一种文件??), 直接用 read ,write  读写  

a UNIX system filter is a program that reads from standard input and writes to standard output

PIPE 只能是单向的,  要其双向传输, 要用到  fork(),   见 pipe.c

系统函数(system calls)决定了什么是UNIX, 其它的(如子例程, 命令)都是建立在系统函数之上, 现如今的UNIX 说明书中有 1100多个 system calls,  书中介绍了最常用的400多个 

od is very useful

for a regular file , the write starts at the file's current offset
   



                       

