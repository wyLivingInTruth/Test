traceroute.h 里面定义了两个 struct ，
 common_sockaddr probe ( probe_struct),  
tr_module (tr_module_struct)

 14 union common_sockaddr {
 15         struct sockaddr sa;
 16         struct sockaddr_in sin;
 17         struct sockaddr_in6 sin6;
 18 };
 19 typedef union common_sockaddr sockaddr_any;

struct probe_struct {
 22         int done;
 23         int final;
 24         sockaddr_any res; // 这个包最终到的 host
 25         double send_time; // double is the return type of get_time() 
 26         double recv_time;
 27         int recv_ttl;
 28         int sk;      // socket number
 29         int seq;     // 这个
 30         char *ext;
 31         char err_str[16];       /*  assume enough   */
 32 };
 33 typedef struct probe_struct probe;
 34 
 35 
 36 struct tr_module_struct { // 这个struct 代表一个什么？
 37         struct tr_module_struct *next;
 38         const char *name;
 39         int (*init) (const sockaddr_any *dest,
 40                                 unsigned int port_seq, size_t *packet_len);  //这里定义了4个函数指针
 41         void (*send_probe) (probe *pb, int ttl);
 42         void (*recv_probe) (int fd, int revents);
 43         void (*expire_probe) (probe *pb);
 44         CLIF_option *options;   /*  per module options, if any   */         // ??? 
 45         short user;     /*  whether applicable for non-root users   */
 46         short one_per_time;     /*  no simultaneous probes   */
 47         size_t header_len;      /*  additional header length (aka for udp)   */
 48 };
 49 typedef struct tr_module_struct tr_module;    // 
 50 

程序是通过 setsockopt(sk, SOL_SOCKET , SO_TIMESTAMP , &n , sizeof(n)),  在  use_timestamp(sk)中调用，    而use_timestamp 在  tune_socket（）中调用
把 use_timestamp中这行给  注释后， 是用  get_time()得到的 pb->recv_time ， 而且数值要大得多，好多达到了， 几千上万 ms

是不是 设置了 setsockopt(sk , SOL_SOCKET,  SO_TIMESTAMP , ..)  以后这个socket 收到的每个包会自己获取接收时间了？

 
static const char *module = "default"   (在 traceroute.c  中 定义）

time.c里面实现,   get_time(),  返回的是double型，  在 traceroute.h 里面声明

moudle.c 里面定义了 static 全局变量  static tr_module * base = NULL
和两个函数   void tr_register_module (tr_module * ops)
          const tr_module * tr_get_module(const char *name) 

DEF_START_PORT 在 traceroute.h 中定义， 在每个 模块 的， init 函数中 使用

tr_module 这个 struct 定义在 traceroute.h 中，  这是一个链表的 struct 

const char *name;
 39         int (*init) (const sockaddr_any *dest,
 40                                 unsigned int port_seq, size_t *packet_len);  //这里定义了4个函数指针
 41         void (*send_probe) (probe *pb, int ttl);
 42         void (*recv_probe) (int fd, int revents);
 43         void (*expire_probe) (probe *pb);  

里面主要是 一个  name , 和  4 个函数指针，都用到了 probe

poll.c里面的几个函数是用来做什么的？？

extension.c里面，有两个结构  icmp_ext_header 和  icmp_ext_object 和两个函数 try_extension(),  handle_extensions()

handle_extensions() 被 traceroute.c 中定义的  recv_reply() 的最后处 调用

而 recv_reply() 只是被各个 module 里面的 .._recv_probe()  所调用了

0 mod-icmp.c    icmp_recv_probe  185 recv_reply (sk, !!(revents & POLLERR), icmp_check_reply);
1 mod-raw.c     raw_recv_probe   143 recv_reply (sk, !!(revents & POLLERR), raw_check_reply);
2 mod-tcp.c     tcp_recv_probe   418 recv_reply (sk, !!(revents & POLLERR), tcp_check_reply);
3 mod-tcpconn.c tcp_recv_probe   210 recv_reply (icmp_sk, 0, tcp_check_reply);
4 mod-udp.c     udp_recv_probe   188 recv_reply (sk, !!(revents & POLLERR), udp_check_reply);

96  static int as_lookups = 0;        in traceroute.c

as_lookups.c 中实现了一个函数  const char *get_as_path (const char *query) (这里的 as 代表什么 ??)
而 get_as_path() 这个函数也只在 print_addr(sockaddr_any * res) 的最后被调用（tracerotue.c)
 689         if (as_lookups)
 690                 printf (" [%s]", get_as_path (str));

 关于 TR_MODULE(MOD) 这个宏 的定义 (traceroute.h)中                                      ！！（这里，研究下这个宏是怎么样，很可能就是这个把 各个  mod-文件和 traceroute.c 联系起来的）
101 static void __init_ ## MOD (void) __attribute__ ((constructor));        \
102 static void __init_ ## MOD (void) {     \
103                                 \
104         tr_register_module (&MOD);      \
105 }

一个有4个 mod- 文件
|-- mod-icmp.c
|-- mod-raw.c
|-- mod-tcp.c
|-- mod-tcpconn.c
|-- mod-udp.c
这些文件的最后都定义了一个 tr_module   struct 
然后再通过  TR_MODULE(..),  把这个 struct 放到 链表中
实际上在整个程序中，只有TR_MODULE(MOD)这个宏用了

recv_reply 这个函数 定义在 traceroute.c 中，
 1251 void recv_reply (int sk, int err, check_reply_t check_reply)
而参数  check_reply_t 是定义在 traceroute.h 中的一个 函数指针
 typedef probe *(*check_reply_t) (int sk, int err, sockaddr_any *from, char *buf, size_t len);

而recv_reply 则（只）被各个 module 的 ..._recv_probe()所调用，各个module会 实现自己的 check_reply_t 类型， **_check_reply() , 作为，  recv_reply()的参数
而这些 module 实现中的 公共部份， 就作为函数实现在 traceroute.c中， 如， recv_reply
probe_done, 

关于  __attribute_ ((constructor)),   __attribute_ ((destructor)) , 的使用，用于函数（声明，或定义）， 表分别在main()之前，或之后调用这个函数，  （收集了一个例子）
声明的话：   void fun () __attribute_ ((constructor))
定义：      __attribute_ ((constructor))  void fun () {...}

在 GCC 文档 第6章， 讲了GCC  对 C 的扩展， Extensions to the C Language Family
使用  __attribute__((...)) 的语法，用在函数声明的最后， 或定义的前面             （这里可以就这一问展开，多讨论下）

````````可以讲像这样的开源软件的源代码是怎么组建的，怎么建立 makefile, 以及，相关shell的接口是怎样实现的

base 是 module.c  中 定义的一个  
static tr_module *base = NULL;		只在这个文件的两个函数中使用了（static)，它最终是指向 module chain 中最前面的那个

```````````````也分析这个程序的出错处理


add_gateway 这个函数 只在 traceroute.c 中 定义的 static CLIF_option option_list[]  中使用了，而只有在  add_gateway 中 才能   num_gateway++ 和 ，增加 gateways 中的值 （char ** gateways)
static int num_gateway;
static char ** gateways;

现在研究  CLIF_parse(), 以及 clif.h 这个头文件， 以及定义的 CLIF_ ...  的结构

----------------------------------
        关于clif.h 首先定义了两个  struct,       CLIF_option 和  CLIF_argument
	接下来就是很多常量定义和 函数声明
	其中这两个函数被我们的程序所使用      CLIF_parse()
					CLIF_print_options()
	前者，在 main 的开头和结束都被调用了， 而且都跟着（条件） exit(2);
	两者都在 set_mod_option()中被调有了，且后者只在这调用了一次

	typedef struct CLIF_option_struct CLIF_option;
 14 struct CLIF_option_struct {
 15         const char *short_opt;
 16         const char *long_opt;
 17         const char *arg_name;
 18         const char *help_string;
 19         int (*function) (CLIF_option *optn, char *arg);
 20         void *data;
 21         int (*function_plus) (CLIF_option *optn, char *arg);
 22         unsigned int flags;
 23 };
 24 #define CLIF_END_OPTION     { 0, 0, 0, 0, 0, 0, 0, 0 }
 25 
 26 typedef struct CLIF_argument_struct CLIF_argument;
 27 struct CLIF_argument_struct {
 28         const char *name;
 29         const char *help_string;
 30         int (*function) (CLIF_argument *argm, char *arg, int index);
 31         void *data;
 32         unsigned int flags;
 33 };
 34 #define CLIF_END_ARGUMENT   { 0, 0, 0, 0, 0 }
 79 extern int CLIF_parse (int argc, char **argv, CLIF_option *option_list,
 80                             CLIF_argument *arg_list, unsigned int parse_flags);

 35 

-----------------------------------------------------------------------------
ops 这个全局变量 ， 应该是指当前命令所要使用的模块

****************************我还要结合iptable 来试用各个module（发各种包）

  -M method
              Use specified method for traceroute operations.  Default  tradi‐
              tional  udp method has name default, icmp (-I) and tcp (-T) have
              names icmp and tcp respectively.
              Method-specific options can be passed by -O .  Most methods have
              their simple shortcuts, (-I means -M icmp, etc).
--------------摘自  man traceroute

每个module都定义了一个 sockaddr_any  的 dest_addr

tune_socket 这个函数是干什么用的？（traceroute.c)中，里面主要是：如果enalbe debug,做什么事， 在每一个 module中的， send_probe函数中，当分配了一个 socket之后（如sk),都调用一次tune_socket(sk)
这个函数是看我们的全局变量 debug 是否设置了，如果设置了就通过   setsockopt(..) 来  enalbe debug tracing,  在每次新建了一个 socket后，都要调用这个函数（tune_socket),来检查全局变量  debug 看是否需要通过 setsockopt（。。） 来 enable debug tracing

123 static probe *probes = NULL;  probes这个变量应该是用来指向所有发的包的数组

在 do_it 中的 发包 for 循环中， 调用 ops->send_probe（pb ,ttl)来发包
在 for 循环的开始，就定义了 probe *pb = &probes[n]，for 中的局部变量，用来指代每次循环发的这个包

在 udp_send_probe里（这里我们假定用的 udp module ( or default ?)
分配了一个socket,  且  connect    dest_addr
接着用 use_recverr(里面调用  setsockopt(..) 对 socket进行了设置（设置的什么还没搞清楚??)
然后就调用 do_send(..) ( defined in traceroute.c)

do_send(..)里，根据不同情况调用  send(..) 或 sendto(..) 来发送数据，  do_send()的返回值是 send()  或  sendto() 的返回值， 发送的字节数， 或-1(出错）

发送了包之后调用 add_poll(..)

在udp_send_probe里面，就是创建一个  socket,然后，通过这个socket把 data 发出去（用 do_send()),并且设置 pb 的相关值 （pb, 是， do_it()调用 opt->send_probe(pb,ttl),作为参数传进去的
udp_send_probe中还 调用了 add_poll(sk , ... )来设置， poll.c中的全局变量  pollfd * pfd

main 在最后调用的是do_it(); (do_it 后面只有 return 0 了）

每个module都定义了自己的  static     dest_addr

后面用getopt改写， 参数分析模块

121.49.86.200	CN	32	Sichuan	Chengdu	N/A	30.666700	104.066704	0	0	Asia/Chongqing	121.49.12.0	121.49.127.255

熟悉 zlib 安   maxmind (C API)

还要修改 makefile 里面，

